#----------------------------------------------------------------------------------------#
#  Screens charcoal peaks for charcoal-area records used to reconstruct past fire        #
#  episodes with the CharAnalysis software, as described in Finsinger et al. (2014).     #
#                                                                                        #
#  For additional details, please refer to Finsinger et al. (2014), or contact:          #
#    Walter Finsinger <walter.finsinger@umontpellier.fr> or else                         #
#    Ryan Kelly <rkelly@life.illinois.edu>.                                              #
#                                                                                        #
#----------------------------------------------------------------------------------------#
#                                                                                        #
# The function requires four file path inputs (see below), as well as the following      #
# additional parameters (which can be left at default values):                           #
#                                                                                        #
#   n.boot      = number of bootstrap samples generated by the function to obtain a      #
#                 distribution of simulated charcoal-areas (default = 10,000)            #
#   thresh.prob = pth percentile threshold used to separate significant                  #
#                 charcoal-area peaks (default = 0.95)                                   #
#   win.width   = temporal span of the window from which bootstrap samples are           #
#                 generated. For each peak to be screened, particles are randomly drawn  #
#                 (with replacement) from all samples within a focal window, which is    #
#                 centered on the peak and has a full span of win.width (default = 1000) #
#   breakage    = if FALSE plots also C#/CA-ratios in diagnostic plot (default = FALSE)  #
#   ff_sm_yr    = Window to smooth peak frequencies over, in years (default = 1000)      #
#   output.dir  = path for output data and figures                                       #
#                   (default = 'arco_output' in current working directory)               #
#                                                                                        #
#----------------------------------------------------------------------------------------#
#                                                                                        #
# The input datasets should be .csv files. For each .csv, provide the full path to the   #
# file as the corresponding function argument. Details of the four files are below, and  #
# examples are included with this code:                                                  #
#                                                                                        #
#   RAW DATA                                                                             #
#     1. Seedle.file  = .csv table with charcoal-particle areas. Should have three       #
#                       columns and as many rows as the number of observations:          #
#                                                                                        #
#         Column 1: Depth     = Depth of samples                                         #
#         Column 2: SdlArea   = Charcoal-particle areas                                  #
#                                                                                        #
#     2. Smpl.file    = .csv table with charcoal counts and charcoal areas. Should have  #
#                       four columns and as many rows as the number of samples:          #
#                                                                                        #
#         Column 1: Depth     = Depth of samples                                         #
#         Column 2: Age_calBP = Age estimate of samples                                  #
#         Column 3: SmplCount = Number of charcoal particles in each sample              #
#         Column 4: SmplArea  = Cumulative charcoal area in each sample                  #
#                                                                                        #
#   FIRE-EPISODE RECONSTRUCTIONS.                                                        #
#     These are output files from the CharAnalysis program (Higuera et al. 2009), which  #
#     is freely available (http://sites.google.com/site/charanalysis/).                  #
#                                                                                        #
#     3. FireA.file   = CharAnalysis output table from analysis of CHARCOAL AREAS        #
#     4. FireC.file = CharAnalysis output table from analysis of CHARCOAL COUNTS and     #
#                       WITH minimum count test, i.e. with CharAnalysis parameter        #
#                       'minCountP' < 1.0 (e.g. 0.05 as in Higuera et al. [2009])        #
#                                                                                        #
# *** Note: CharAnalysis files must have columns in the expected order, specifically:    #
#                                                                                        #
#   Column 2:  "age Top_i", the age at the top of the interpolated sample                #
#   Column 8:  "char Peak", the Cpeak component of CHAR                                  #
#   Column 12: "thresh FinalPos", the threshold used for peak identification             #
#   Column 19: "peaks Final", the boolean series representing identified peaks           #
#                                                                                        #
#----------------------------------------------------------------------------------------#
#                                                                                        #
# References:                                                                            #
#                                                                                        #
#   Finsinger, W., R. Kelly, J. Fevre, and E.K. Magyari. 2014. A guide to screening      #
#     charcoal peaks in macrocharcoal-area records for fire episode reconstructions.     #
#     The Holocene XX: XXXX. doi: 10.1177/0959683614534737                               #
#                                                                                        #
#   Higuera, P.E., L.B. Brubaker, P.M. Anderson, F.S. Hu, and T.A. Brown. 2009.          #
#     Vegetation mediated the impacts of postglacial climate change on fire regimes in   #
#     the south-central Brooks Range, Alaska. Ecological Monographs 79:201â€“219.          #
#                                                                                        #
#----------------------------------------------------------------------------------------#
  
arco = function(Seedle.file, Smpl.file, FireA.file, FireC.file, 
                n.boot=10000, thresh.prob=0.95, win.width=1000, breakage=FALSE, ff_sm_yr=1000,
                output.dir=file.path(".","arco_output"))
{

# -------------------- SETUP -------------------- #

# ----- Load required libraries
  require(MASS)
  require(car)
  require(stats)
  require(plyr)
  
# ----- Create output directory
  dir.create(output.dir)

# ----- LOAD files with Charcoal per sample and of Seedles
  # file with charcoal-particle areas
    Seedle <- read.csv(Seedle.file, header=T, sep = ",")
    
  # file with charcoal counts and charcoal areas
    Smpl <- read.csv(Smpl.file, header=T, sep = ",")

# ----- LOAD files with Fire history derived from CharAnalysis
  # CharAnalysis output, with Charcoal areas
    CA.dat <- read.csv(FireA.file, header=T, sep = ",", na.strings="#N/A")
    CA.dat <- CA.dat[complete.cases(CA.dat[ ,1]), ]

  # CharAnalysis output, with Charcoal counts WITH pMinCount
    CC.dat <- read.csv(FireC.file, header=T, sep = ",", na.strings="#N/A")
    CC.dat <- CC.dat[complete.cases(CC.dat[ ,1]), ]
  
# ----- Define minimum-area bootstrapping function 
  b.stat <- function(seedle.areas, sample.size, n.boot, thresh.prob) { 
      rj.resample = matrix(sample(seedle.areas, sample.size*n.boot, replace=T), nrow=n.boot)
      rj.sum = apply(rj.resample, 1, sum)
      return( quantile(rj.sum, probs=thresh.prob) )
  }

# ------- Add Seedle counts to Seedle data.frame
  if (min(Seedle$SdlArea) == 0) {      # thus if Seedle file contains zeros 
    S <- Seedle[which(Seedle$SdlArea > 0), ]
  } else {
    S <- Seedle
  }
  
  SdlCounts <- count(S, vars="Depth")
  
  Seedle2 <- merge(Seedle, SdlCounts, by="Depth", all.x=T)
  colnames(Seedle2) [3] <- "SdlCounts" 
  Seedle2$SdlCounts[is.na(Seedle2$SdlCounts)] <- 0
  Seedle2 <- Seedle2[ ,c(1,3,2)]
  
  Seedle <- Seedle2
  
  rm(S, SdlCounts, Seedle2)
  
  
# ------- Add ages to each Seedle (used later for local bootstrapping)
  Age <- Smpl[ ,-c(3,4)]
  Seedle <- merge(Seedle, Age, by.x = "Depth", all.y = FALSE)


# ----- Extract CharAnalysis data to obtain identified peaks and samples above threshold. 
  CA.age    = CA.dat[,2]
  CA.cpeak  = CA.dat[,8]
  CA.thresh = CA.dat[,12]
  CA.peaks  = CA.dat[,19]
  CA.res    = diff(CA.age[1:2]) # Assuming interpolated ages, as usual for CharAnalysis

  CC.age    = CC.dat[,2]
  CC.cpeak  = CC.dat[,8]
  CC.thresh = CC.dat[,12]
  CC.peaks  = CC.dat[,19]
  CC.res    = diff(CC.age[1:2])



# -------------------- SCREENING -------------------- #

# ----- Find all samples contributing to peaks identified by CharAnalysis
  # Obtain peaks identified by CharAnalysis
    peak.ind = which(CA.peaks==1)
      n.peak = length(peak.ind)

  # Create some variables
    overthresh.ind  = peaksamples.ind = peaksamples.count = peaksamples.area = peaksamples.age = list()
    overthresh.interval = matrix(NA,nrow=n.peak,ncol=2)
    
  # Loop over all identified peaks to find all samples contributing to each peak. (Because when multiple samples in a row exceed the threshold, CharAnalysis marks only the lowermost as a peak.)
    for(i in 1:n.peak) {
      # Start with the sample identified as the peak
        overthresh.ind[[i]] = peak.ind[i]
      
      # If the first peak is in the first sample, don't look for other samples belonging
        # to the peak
        if(peak.ind[1] == 1) {
          overthresh.ind[[1]] = peak.ind[1]
        } else {
        
      # Else Look for other samples belonging to this peak
        ind.cur = peak.ind[i]-1                         # start with the next sample above...
        while(CA.cpeak[ind.cur]>CA.thresh[ind.cur]) {   # if it's also above the threshold...
          overthresh.ind[[i]] = c(overthresh.ind[[i]], ind.cur)  # add it to 'overthresh.ind'...
          ind.cur = ind.cur-1                           # and get ready to check the next sample above.
        }
        }
  
      # For each peak, find the full age interval spanned by all samples exceeding the threshold.
        overthresh.interval[i,] = c( min(CA.age[overthresh.ind[[i]]]),
                                     max(CA.age[overthresh.ind[[i]]])+CA.res ) 

      # Now go to the original data (i.e. not the CharAnalysis-interpolated data) and find all samples that contribute to each peak identified in CharAnalysis
        peaksamples.ind[[i]] = which( Smpl$Age_calBP>=overthresh.interval[i,1] & 
                                      Smpl$Age_calBP<=overthresh.interval[i,2] )

        # Add the sample that has its top depth just above the top of the peak interval, since it partially contributes to the peak as well. 
        peaksamples.ind[[i]] = union( peaksamples.ind[[i]],
           which.min( sapply(overthresh.interval[i,1] - Smpl$Age_calBP, function(x) ifelse(x<0,NA,x))) )

      # Finally, extract the original count, area, and age data for all of these samples.
        peaksamples.count[[i]] = Smpl$SmplCount[ peaksamples.ind[[i]] ]
        peaksamples.area[[i]] = Smpl$SmplArea[ peaksamples.ind[[i]] ]
        peaksamples.age[[i]] = Smpl$Age_calBP[ peaksamples.ind[[i]] ]
    }


# ----- Separate the seedle areas for peak vs. non-peak samples
  # First, find the age intervals not spanned by peaks, i.e. anything not covered by overthresh.interval.
    underthresh.interval = matrix(NA, nrow=n.peak+1, ncol=2)
      underthresh.interval[1,1] = min(CA.age)
      underthresh.interval[2:(n.peak+1),1] = overthresh.interval[,2]
      underthresh.interval[1:n.peak,2] = overthresh.interval[,1]
      underthresh.interval[(n.peak+1),2] = max(CA.age) + CA.res

  # Then loop over each non-peak interval to find all samples in the original data that did not contribute to a CharAnalysis-identified peak.
    nonpeaksamples.ind = list()
    for(i in 1:(n.peak+1)) {
      nonpeaksamples.ind[[i]] = which( Smpl$Age_calBP>=underthresh.interval[i,1] & 
                                       Smpl$Age_calBP<=underthresh.interval[i,2] )

      # Add the sample that has its top depth just above the top of the non.peak interval, since it partially contributes to the non.peak as well. 
        nonpeaksamples.ind[[i]] = union( nonpeaksamples.ind[[i]],
              which.min( sapply(underthresh.interval[i,1] - Smpl$Age_calBP, function(x) ifelse(x<0,NA,x))) )
    }

  # Finally, get the seedle data associated with peak and non-peak samples. Data in 'Seedle' table is linked to samples in the 'Smpl' table by depth.  
    nonpeak.Seedle = 
      Seedle[ sapply(Seedle$Depth, function(x) {x %in% Smpl$Depth[unlist(nonpeaksamples.ind)]}), ]
    peak.Seedle = 
      Seedle[ sapply(Seedle$Depth, function(x) {x %in% Smpl$Depth[unlist(peaksamples.ind)]}), ]


# ----- Perform screening
  # Create space for output
    screen.pass = rep(0, n.peak)      # begin with the assumption that no peaks pass the screening
    area.thresh = rep(NA,nrow(Smpl))
  
  # Loop over each CharAnalysis-identified peak...
    for(i in 1:n.peak) {
      # ...which contains one or more samples from the original data (loop over each of those too)...
      for(j in 1:length(peaksamples.ind[[i]])) {
        # Find all the non-peak seedle data that is within the specified temporal window surrounding the peak sample being analyzed on this iteration. 
          seedles.j.ind = which( 
            nonpeak.Seedle$Age_calBP >= (peaksamples.age[[i]][j] - win.width/2) &
            nonpeak.Seedle$Age_calBP <= (peaksamples.age[[i]][j] + win.width/2)
            ) 
        
        # Obtain the seedle areas for the identified non-peak samples in the window
          seedles.j = Seedle$SdlArea[ seedles.j.ind ]

        # Bootstrap an area threshold from those areas
          area.thresh[ peaksamples.ind[[i]][j] ] = 
            b.stat(seedles.j, peaksamples.count[[i]][j], n.boot, thresh.prob)

        # If the peak sample being analyzed exceeds the bootstrap threshold value, then increment the value of 'screen.pass'
        if( peaksamples.area[[i]][j] > area.thresh[ peaksamples.ind[[i]][j] ] ) {
           screen.pass[i] = screen.pass[i] + 1
        }
      }
    }

  # If at least one of the original samples contributing to a CharAnalysis peak is beyond its bootstrapped threshold, then that CharAnalysis peak passed the screening. 
    peak.ind.screened = peak.ind[which(screen.pass>0)]
    peak.ind.notpass = peak.ind[which(screen.pass<1)]


# ----- Prepare output files
  # Results related to area screening
    comp.perc = cbind(Smpl, area.thresh)
    comp.perc$differ = comp.perc$SmplArea - comp.perc$area.thresh
    comp.perc$val = as.numeric( comp.perc$differ>0 ) # as.numeric converts T/F to 1/0
    comp.perc$frag = comp.perc$SmplCount/comp.perc$SmplArea
    write.csv(comp.perc, file.path(output.dir, "comp_perc.csv"), row.names = FALSE)
    
   
  # New CharAnalysis output file that reflects peak-area screening
    CA.dat.out = CA.dat                                       # Start with the original CA data
      CA.dat.out[-peak.ind.screened,19] = 0                   # Remove screened peaks from "peaks Final"
      CA.dat.out[setdiff(peak.ind,peak.ind.screened),20] = 1  # Add them to "peaks Insig."

      
    # peakFrequ. Peak analysis summary includes a smoothed fire-frequency curve.
    # The smoothing window for the analysis is entered in the parameter peakFrequ (in years). By default, PeakFrequ=1000
    # Thus, the total number of fires within a 1000-yr period are summed, and then this series is smoothed with a Lowess smoother.
    # Largely built on Matlab source code (CharPeakAnalysisResults_conPDF.m) that was written by Phil Higuera 7 May 2014
    # see https://github.com/phiguera/CharAnalysis/blob/master/CharAnalysis_1_1_MATLAB/CharPeakAnalysisResults_conPDF.m
    
    # First set full window width over which number of fires are summed, thus defining dimension as (# fires/1000 years)
    peakFrequ <- 1000 # [yr]
    
    CA.peaks <- CA.dat.out[ ,19]
    
    ff_sum_yr <- peakFrequ # [yr] Window to sum peaks over.
    half.win <- ff_sum_yr/2          # [yr] # [datapoints] Window corresponding to smoothing-window half width
    n.row.halfwin <- half.win/CA.res # [datapoints] Window corresponding to ff_sum_yr half width
    
    
    ff_sm_span.points <- round(ff_sm_yr/CA.res) # [datapoints] Window to smooth peak frequencies over
    ff_sm_span.prop <- ff_sm_span.points/length(CA.age) # [proportion] span of lowess/loess to smooth peak frequencies over
    
    # Make space in empty matrix
    Charcoal.peaksFrequ <- matrix(data=NA, nrow=length(CA.age), ncol=1)
    
    # Get the total number of fires within a 1000-yr period and calculate their frequencies (as # fires / 1000 years)
    for (i in 1:length(CA.age)) {
      if (i < n.row.halfwin) { # If start of record
        Charcoal.peaksFrequ [i] <- sum(CA.peaks[1:n.row.halfwin+i]) *
          round(ff_sum_yr/CA.res) / floor((ff_sum_yr/CA.res)/2+i)
        # Charcoal.peaksFrequ [i] <- sum(CA.peaks[1:n.row.halfwin+i]) * (round(half.win) / floor(n.row.halfwin+i))
      }
      
      if (i > (length(CA.age) - n.row.halfwin))   {  # If end of record
        start.bound <- ceiling(i-n.row.halfwin)  # defines where it should start counting Charcoal Peaks
        Charcoal.peaksFrequ [i] <- sum(CA.peaks[start.bound:length(CA.age)]) /
          ((length(CA.peaks) - start.bound) * CA.res)
      }
      
      if (i >= n.row.halfwin && i <= (length(CA.age)-n.row.halfwin)) {  # Else, it's the middle of the record.
        Charcoal.peaksFrequ [i] <- sum(CA.peaks[(ceiling(i-n.row.halfwin)):(ceiling(i+n.row.halfwin)) ]) /
          (2*n.row.halfwin * (CA.res))
      }
    }
    
    # Add CA.age
    Charcoal.peaksFrequ <- as.data.frame(cbind(CA.age, Charcoal.peaksFrequ))
    colnames(Charcoal.peaksFrequ) [2] <- "CA.ff"
      
    # Loess
    ff_sm_loess <- loess(formula=CA.ff~CA.age, data=Charcoal.peaksFrequ, span=ff_sm_span.prop, degree=1)
    ff_loess.pred <- predict(ff_sm_loess, newdata=Charcoal.peaksFrequ$CA.age, se=F)
      
    # Write loess-predicted values into the CA.dat.out data.frame
    CA.dat.out <- cbind(CA.dat.out[ ,1:21], ff_loess.pred, CA.dat.out[ ,23:33])
      
  # Add column names and write to disk
    CA.colnames = c("cm Top_i (cm)","age Top_i_(yr BP)","char Count_i (#)","char Vol_i (cm3)",
                    "char Con_i (# cm-3)","char Acc_i (# cm-2 yr-1)","charBkg (# cm-2 yr-1)","char Peak (# cm-2 yr-1)",
                    "thresh 1 (# cm-2 yr-1)","thresh 2 (# cm-2 yr-1)","thresh 3 (# cm-2 yr-1)","thresh FinalPos (# cm-2 yr-1)","thresh FinalNeg (# cm-2 yr-1)",
                    "SNI (index) ","thresh GOF (p-val)","peaks 1 ","peaks 2 ","peaks 3 ","peaks Final","peaks Insig.",
                    "peak Mag (# cm-2 peak-1)","smPeak Frequ (peaks 1ka-1)","smFRIs (yr*fire-1)","nFRIs (#)",
                    "mFRI (yr fire-1)","mFRI_uCI (yr fire-1)","mFRI_lCI (yr fire-1)",
                    "WBLb (yr)","WBLb_uCI (yr)","WBLb_lCI (yr fire-1)","WBLc (unitless)","WBLc_uCI (unitless)","WBLc_lCI (unitless)")

    write.table(CA.dat.out, file.path(output.dir, "FireA_screened.csv"), col.names=CA.colnames, row.names=F, sep=",")



# -------------------- PLOTS -------------------- #

## Plots Seedle_area, C#/CA-ratio, and Sample Area vs Char_counts ####
pdf(file.path(output.dir, "1_Counts_Areas.pdf"))
par(mfrow=c(3,1), cex.lab=1.2)
par(mar = c(0.5, 6, 0.5, 5))
par(oma = c(5,1,1,10))
plot(Seedle$SdlCounts, Seedle$SdlArea, ylab = expression(Particle~area~mm^{2}), pch = 20, xlim=(range(Smpl$SmplCount)), xaxt = "n")
plot(Smpl$SmplCount, Smpl$SmplArea, ylab = expression(Charcoal~area~(C[A]~(mm^{2}))), pch = 20, xlim=(range(Smpl$SmplCount)), xaxt = "n")
abline(lm(Smpl$SmplArea ~ Smpl$SmplCount))
plot(Smpl$SmplCount, Smpl$SmplCount/Smpl$SmplArea, ylab = expression(C["#"]/C[A]-ratio), pch = 20, xlim=(range(Smpl$SmplCount)))
mtext(expression(Charcoal~counts~(C["#"]~(pieces~sample^{-1}))), side = 1, outer = TRUE, line = 2.5)
dev.off()


## Extract only Seedles of Screened peak samples (called 'val' samples) ####
valSmpl.perc <- comp.perc[which(comp.perc$val==1), ]
valSdl.perc <- merge(Seedle, valSmpl.perc[,-2], by.x = "Depth", all.x = FALSE)
  boxplot(SdlArea ~ Age_calBP, varwidth = TRUE, notch = FALSE, xlab = "Age (cal yrs BP)", ylab = expression(paste("Char.-particle area mm"^"2")), data=valSdl.perc)


# Comparison between screened and unscreened samples #####
valAllSdl.perc <- merge(Seedle, comp.perc[,-2], by.x = "Depth", all.y = TRUE)
with (valAllSdl.perc, {
  pdf(file.path(output.dir, "2_Boxplots_all_Samples_Perc.pdf"))
  par(mai = c(1,1,0.5,0.5), cex.axis = 1.2, cex.lab = 1.3)
  boxplot(SdlArea~val, data=valAllSdl.perc, subset=SdlCounts>0, names=c("non signif. peaks", "signif. peaks"), ylab=expression(paste("Particle area mm"^"2")), notch=TRUE, varwidth=TRUE)
  dev.off()
})


# Diagnostic plot ####
# (Screened CA and CC peaks that failed screening test = grey dots)
pdf(file.path(output.dir, "3_Diagnostic.pdf"))
if(breakage) {
  par(mfrow=c(3,1))
  par(mar = c(0.5, 5, 0.5, 5))
  par(oma = c(5,1,1,1))
  y.lim = c(min(CA.cpeak), 1.2*max(CA.cpeak))
  plot(0,0, type='n', xlim=rev(range(CA.age)), ylim=y.lim, ylab=expression(CHAR[A]*~"residuals"), xaxt="n", cex=1)
  for(i in 1:n.peak) {
    polygon(c(overthresh.interval[i,],rev(overthresh.interval[i,])),
            rep(y.lim, each=2), col="mistyrose", border=NA) }
  for(i in 1:(n.peak+1)) {
    polygon(c(underthresh.interval[i,],rev(underthresh.interval[i,])),
            rep(y.lim, each=2), col="lightcyan", border=NA) }
  
  lines(CA.age,CA.cpeak, type='s', col=grey(0.5))
  abline(h=0, col=grey(0.5))
  lines(CA.age,CA.thresh, col=2)
  
  points(CA.age[peak.ind.notpass]+CA.res/2, rep(0.9*y.lim[2], length(peak.ind.notpass)), col="gray", pch=16, cex=1)
  points(CA.age[peak.ind.screened]+CA.res/2, rep(0.9*y.lim[2], length(peak.ind.screened)), col=2, pch=3, lwd=2)
  
  
  y.lim = c(min(Smpl$SmplCount), 1.2*max(Smpl$SmplCount))
  plot(0,0, type='n', xlim=rev(range(CA.age)), ylim=y.lim, ylab=expression(Char.~counts~(pieces*~sample^{"-1"})), xaxt="n", cex=1)
  for(i in 1:nrow(overthresh.interval)) {
    polygon(c(overthresh.interval[i,],rev(overthresh.interval[i,])),
            rep(y.lim, each=2), col="mistyrose", border=NA) }
  for(i in 1:(n.peak+1)) {
    polygon(c(underthresh.interval[i,],rev(underthresh.interval[i,])),
            rep(y.lim, each=2), col="lightcyan", border=NA) }
  
  lines(Smpl$Age_calBP, Smpl$SmplCount, type='s', col=grey(0.5))
  abline(h=0, col=grey(0.5))
  
  points(CA.age[peak.ind.notpass]+CA.res/2, rep(0.9*y.lim[2], length(peak.ind.notpass)), col="gray", pch=16, cex=1)
  points(CA.age[peak.ind.screened]+CA.res/2, rep(0.9*y.lim[2], length(peak.ind.screened)), col=2, pch=3, lwd=2)
  
  y.lim = c(min(CC.cpeak)+0.01, 1.2*max(CC.cpeak))
  plot(0,0, type='n', xlim=rev(range(CA.age)), ylim=y.lim, ylab=expression(CHAR["#"]*~"residuals"), cex=1)
  
  lines(CC.age, CC.cpeak, type='s', col=grey(0.5))
  abline(h=0, col=grey(0.5))
  lines(CC.age,CC.thresh, col=2)
  
  ind = which(CC.dat[,20]==1)
  points(CC.age[ind], rep(0.7*y.lim[2], length(ind)), col="gray", pch=16, cex=1)
  ind = which(CC.dat[,19]==1)
  points(CC.age[ind], rep(0.7*y.lim[2], length(ind)), col="red", pch=3, lwd=2)
  
  mtext(("Age (cal yrs BP)"), side = 1, line = 2.5, cex = 1)
} else {
  par(mfrow=c(4,1))
  par(mar = c(0.5, 5, 0.5, 5))
  par(oma = c(5,1,1,1))
  y.lim = c(min(CA.cpeak), 1.2*max(CA.cpeak))
  plot(0,0, type='n', xlim=rev(range(CA.age)), ylim=y.lim, ylab= expression(CHAR[A]*~"residuals"), xaxt="n", cex=1)
  for(i in 1:n.peak) {
    polygon(c(overthresh.interval[i,],rev(overthresh.interval[i,])),
            rep(y.lim, each=2), col="mistyrose", border=NA) }
  for(i in 1:(n.peak+1)) {
    polygon(c(underthresh.interval[i,],rev(underthresh.interval[i,])),
            rep(y.lim, each=2), col="lightcyan", border=NA) }
  
  lines(CA.age,CA.cpeak, type='s', col=grey(0.5))
  abline(h=0, col=grey(0.5))
  lines(CA.age,CA.thresh, col=2)
  
  points(CA.age[peak.ind.screened]+CA.res/2, rep(0.9*y.lim[2], length(peak.ind.screened)), col=2, pch=3, lwd=2)
  points(CA.age[peak.ind.notpass]+CA.res/2, rep(0.9*y.lim[2], length(peak.ind.notpass)), col="gray", pch=16, cex=1)
  
  
  y.lim = c(min(Smpl$SmplCount), 1.2*max(Smpl$SmplCount))
  plot(0,0, type='n', xlim=rev(range(CA.age)), ylim=y.lim, ylab=expression(Char.~counts~(pieces*~sample^{"-1"})), xaxt="n", cex=1)
  for(i in 1:nrow(overthresh.interval)) {
    polygon(c(overthresh.interval[i,],rev(overthresh.interval[i,])),
            rep(y.lim, each=2), col="mistyrose", border=NA) }
  for(i in 1:(n.peak+1)) {
    polygon(c(underthresh.interval[i,],rev(underthresh.interval[i,])),
            rep(y.lim, each=2), col="lightcyan", border=NA) }
  
  lines(Smpl$Age_calBP, Smpl$SmplCount, type='s', col=grey(0.5))
  abline(h=0, col=grey(0.5))
  
  points(CA.age[peak.ind.screened]+CA.res/2, rep(0.9*y.lim[2], length(peak.ind.screened)), col=2, pch=3, lwd=2)
  points(CA.age[peak.ind.notpass]+CA.res/2, rep(0.9*y.lim[2], length(peak.ind.notpass)), col="gray", pch=16, cex=1)
  
  
  Smpl$frag = Smpl$SmplCount/Smpl$SmplArea
  is.na(Smpl) <- sapply(Smpl, is.infinite)
  y.lim = c(0, 1.2*max(Smpl$frag, na.rm=TRUE))
  plot(0,0, type='n', xlim=rev(range(CA.age)), ylim=y.lim, ylab=expression(C["#"]/C[A]-ratio), xaxt="n", cex=1)
  for(i in 1:nrow(overthresh.interval)) {
    polygon(c(overthresh.interval[i,],rev(overthresh.interval[i,])),
            rep(y.lim, each=2), col="mistyrose", border=NA) }
  for(i in 1:(n.peak+1)) {
    polygon(c(underthresh.interval[i,],rev(underthresh.interval[i,])),
            rep(y.lim, each=2), col="lightcyan", border=NA) }
  
  points(Smpl$Age_calBP, Smpl$frag, xlim=rev(range(CA.age)), pch=16, cex=1)
  abline(h=0, col=grey(0.5))
  
  
  y.lim = c(min(CC.cpeak)+0.01, 1.2*max(CC.cpeak))
  plot(0,0, type='n', xlim=rev(range(CA.age)), ylim=y.lim, ylab=expression(CHAR["#"]*~"residuals"), cex=1)
  
  lines(CC.age, CC.cpeak, type='s', col=grey(0.5))
  abline(h=0, col=grey(0.5))
  lines(CC.age,CC.thresh, col=2)
  
  ind = which(CC.dat[,20]==1)
  points(CC.age[ind], rep(0.7*y.lim[2], length(ind)), col="gray", pch=16, cex=1)
  ind = which(CC.dat[,19]==1)
  points(CC.age[ind], rep(0.7*y.lim[2], length(ind)), col="red", pch=3, lwd=2)
  
  mtext(("Age (cal yrs BP)"), side = 1, line = 2.5, cex = 1)
}
dev.off()


# Plots comparison between fire events #####
pdf(file.path(output.dir, "4_Comparison fire events.pdf"))
par(mfrow=c(1,1))
  y.lim = c(min(CA.cpeak), 1.7*max(CA.cpeak))
  plot(0,0, type='n', xlim=rev(range(CA.age)), ylim=y.lim, ylab=expression(CHAR[A]*~mm^{2}), xlab="Age cal BP")
  lines(CA.age,CA.cpeak, type='s', col=grey(0.5))
  abline(h=0, col=grey(0.5))
  lines(CA.age,CA.thresh, col=2)
 
  ind = which(CA.dat[,19]==1)
  points(CA.age[ind]+CA.res/2, rep(0.8*y.lim[2], length(ind)), pch=16, col="grey", cex=0.7)

  ind = peak.ind.screened
  points(CA.age[ind]+CA.res/2, rep(0.8*y.lim[2], length(ind)), pch=17, cex=0.9)

  ind = which(CC.dat[,20]==1)
  points(CA.age[ind]+CA.res/2, rep(0.7*y.lim[2], length(ind)), pch=16, col="grey", cex=0.8)

  ind = which(CC.dat[,19]==1)
  points(CA.age[ind]+CA.res/2, rep(0.7*y.lim[2], length(ind)), pch=18, cex=1.0)

  legend("topright", bty='n', legend = c(expression(CHAR[A]*~screened), expression(CHAR[C]*~screened), "Unscreened"), 
         pch=c(17,18,16), col=c("black","black","grey"), ncol=2, cex=.8)
dev.off()



## Calculates FRIs for CA, CAscreen, CC, and CCscreen fire-episode histories
FRI.CA = CA.dat[CA.dat[,19]==1,1:2]
FRI.CA$FRI <- c(diff(FRI.CA[,2]), NA)

FRI.CAs = CA.dat[CA.dat.out[,19]==1,1:2]
FRI.CAs$FRI <- c(diff(FRI.CAs[,2]), NA)

FRI.CC = CC.dat[ (CC.dat[,19]==1 | CC.dat[,20]==1), 1:2]
FRI.CC$FRI = c(diff(FRI.CC[,2]), NA)

FRI.CCs = CC.dat[CC.dat[,19]==1,1:2]
FRI.CCs$FRI = c(diff(FRI.CCs[,2]), NA)


## FRI plots - with boxplots
pdf(file.path(output.dir, "5_FRI_plot.pdf"))
par(mfrow=c(2,2))
par(mar = c(0.5, 4, 0.5, 0))
par(oma = c(5,1,1,1))
y.lim = c(min(FRI.CA$FRI, na.rm=T), 1.3*max(FRI.CAs$FRI, na.rm=T))
plot(0,0, type="n", ylim=y.lim, xlim=rev(range(CA.age)), ylab=expression(CHAR[A]*~FRI), xaxt="n")
points(FRI.CA[,2], FRI.CA[,3], pch=16, col="grey", cex=0.7)
points(FRI.CAs[,2], FRI.CAs[,3], pch=17, cex=0.9)
legend("topleft", bty='n', legend = c("Screened", "Unscreened"), 
       pch=c(17,16), col=c("black","grey"), ncol=2, cex=.8)

par(mar = c(0.5, 5, 0.5, 0.5))
boxplot(FRI.CA[,3], FRI.CAs[,3], axes=TRUE, varwidth=TRUE, ylab=expression(CHAR[A]*~FRI))

par(mar = c(0.5, 4, 0.5, 0))
y.lim = c(min(FRI.CC$FRI, na.rm=T), 1.3*max(FRI.CCs$FRI, na.rm=T))
plot(0,0, type="n", ylim=y.lim, xlim=rev(range(CA.age)), ylab=expression(CHAR["#"]*~FRI))
points(FRI.CC[,2], FRI.CC[,3], pch=16, col="grey", cex=0.7)
points(FRI.CCs[,2], FRI.CCs[,3], pch=18, cex=1.0)
mtext("Age (cal yr BP)", side=1, outer = TRUE, line = 2.5, cex = 1)
legend("topleft", bty='n', legend = c("Screened", "Unscreened"), 
       pch=c(18,16), col=c("black","grey"), ncol=2, cex=.8)

par(mar = c(0.5, 5, 0.5, 0.5))
boxplot(FRI.CC[,3], FRI.CCs[,3], axes=TRUE, varwidth=TRUE, names=c("unscreened", "screened"), ylab=expression(CHAR["#"]*~FRI))
dev.off()

# Boxplot of charcoal-particle areas of samples that passed the screening test 
with (valSdl.perc, {
  pdf(file.path(output.dir, "6_Boxplots_Screened_Samples.pdf"))
  par(mai = c(1,1,0.5,0.5), cex.axis = 1.2, cex.lab = 1.3)
  boxplot(SdlArea ~ Age_calBP, varwidth = TRUE, notch = FALSE, xlab = "Age (cal yrs BP)", ylab = expression(paste("Char.-particle area mm"^"2")))
  dev.off()
})

}

# Welcome
cat("Hi there, welcome to charcoal-area peak screening for fire-episode reconstruction.\n")
